# 2. 리팩터링 원칙

#### 리팩터링 정의

소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

리팩터링 과정에서 발견한 버그는 리팩터링 후에도 그대로 남아 있어야 한다.

리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.   
_**프로그램 성능은 좋아질 수도 나빠질 수도 있다.**_   
\(리팩터링에 성능 최적화가 반드시 포함되어 있는 것은 아니다.\)

#### 두개의 모자

소프트웨어 개발\(두개의 모자\) = 기능 추가 or 리팩터링

* 기능 추가 : 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.
* 리팩터링: 기능 추가는 절대 하지 않고, 오로지 코드 재구성에만 전념한다.

소프트웨어 개발 시, 하고자 하는 것이 무엇인지 명확하게 정립되어야 한다.  
모자에 빗대어 표현한 이유는 두개를 동시에 하지 말고 기능을 추가할 땐, 기능 추가에만 전념해야 한다는 뜻이다.

#### 리팩터링을 하는 이유

* _소프트웨어 설계가 좋아짐_ ㅡ 의도한 아키텍처를 유지하며, 코드의 전반 구조를 유지 할 수 있다. 의도한 내부 설계를 유지 하지 않으면, 시간이 지나 중복코드가 남발되고 전체 코드량이 길어진다.
* _소프트웨어를 이해하기 쉬워짐_ ㅡ 코드의 목적이 드러나게, 의도를 명확히 전달 할 수 있다. 자기 자신이 작성한 코드인데 세월이 지나 다시 확인할 때 자기가 짠거 이해 못할 때가 있다ㅋㅋ
* _버그를 쉽게 찾을 수 있음_ ㅡ 코드를 자연스럽게 파악하게 된다.
* _프로그래밍 속도를 높일 수 있음_ ㅡ 프로그램의 기능이 누적될수록 특정 기능을 코드베이스에 녹여내야 하기 때문에 평소에 리팩토링이 잘되어 있었다면, 기능 추가/수정에 많은 시간을 쏟을 필요가 없다.

> 내 생각을 간단히 주저리 주저리 적어보자면, 프로젝트 시작전 어느정도 아키텍처 설계에 불타오르게 되고, 개발 초기에 대부분의 개발자들이 기능 개발 시, 나름 아키텍처의 형상이 잘 유지한다. 하지만 나의 경험상, 아키텍처가 무너지는 경우는 크게 2가지였다. 해당 코드를 작성한 담당자가 변경됐을 때, 그리고 프로그램 개발에 시간이 쫓길 때였다.

> 첫째로, 코드를 작성한 담당자가 변경 됐을 때.   
> 코드 작성엔 프로그램 작성자의 주관이 들어가기 마련이다. 해당 코드의 다음 작성자가 기존 코드의 의도를 충분히 이해하지 않은 채 작성하게 되어 코드 읽기가 불편해지는 경우가 있다. 또, 여기서 "프로그램 작성자의 주관" 이라는 것을 경계해야 하는데, 코드의 원작성자와 다음 작성자의 주관이 서로 달라 다음 작성자가 코드를 수정하는 경우이다. 이때, 잘못하면 수정 중에 기존 코드의 골격이 무너질 수 있게 되는데\(본인이 이해하기 쉽게 바꾸고자\) 이때 리팩토링을 진행할 때 조심해야 한다.

> 둘째, 프로그램 개발에 시간이 부족할때.  
> 보통 작성한 프로그램이 QA Cycle 에 진입하여 다량의 버그가 발생한 경우, Hotfix 패치가 배포되어야 할 때 그런 상황을 종종 목격했다. 기존 개발 담당자와 버그/Hotfix 패치의 담당자가 서로 다를 경우 아키텍쳐가 무너지는 문제는 더 심각했다. 이런 상황을 경계하자.

#### 리팩터링은 언제?

1. 그냥 한다.
2. 비슷한 일을 두번 이상 한다고 생각했을 때는 참아보자..
3. 삼진 아웃. 리팩토링 한다.

* 리팩터링하기 가장 좋은 시점은 기존 코드에 새로운 기능을 추가하기 직전이다.
* 코드의 의미가 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. -&gt; 내가 이해한 것을 코드에 반영한다. 다른 사람도 비슷하게 이해하기 때문이다.
* 코드가 비효율적으로 돌아가거나 기능을 중복해서 작성한 경우엔 즉시 고치는 것이 낫다. 그러나, 시간이 다소 소요되는 것은 짧게 메모해둔다.
* 팀 전체가 오랜 기간 리팩터링에 매달리는 것은 좋지 않다. 관련 코드를 작성할 때, 조금씩 개선해나가는 것만으로도 충분하다.
* 라이브러리를 교체하는 경우, 기존/새것의 라이브러리를 모두 수용할 수 있도록 추상 인터페이스를 생성하는 방법이 깔끔하다.





